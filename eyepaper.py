# -*- coding: utf-8 -*-
"""eyePaper.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QfdYkzI6Cz_yP6leEnFnkgHWGNmZAQfy
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
eyeData = pd.read_csv('/content/drive/MyDrive/gaze.csv')

eyeData

texture = eyeData['iris_texture'].value_counts()
texture

print('number of variables:',eyeData.shape[1])
print('datatypes:\n',eyeData.dtypes)

eyeData = eyeData.drop(columns = 'countFrame')
#eyeData = eyeData.drop(columns = 'iris_texture')

eyeData = eyeData.drop(columns = 'gaze_x')
eyeData = eyeData.drop(columns = 'gaze_y')
eyeData = eyeData.drop(columns = 'gaze_z')
#eyeData = eyeData.drop(columns = 'iris_texture')



features =[ "iris_size", "pupil_size"  , "eyeCorner_x"  , "eyeCorner_y"  , "headPose_x"  ,"headPose_y" , "iris_x",  "iris_y" ]
features1 =["gaze_x","gaze_y", "gaze_z", "iris_size", "pupil_size"  , "eyeCorner_x"  , "eyeCorner_y"  , "headPose_x"  ,"headPose_y" , "iris_x",  "iris_y" ,'cluster']

import matplotlib.pyplot as plt
plt.scatter( eyeData['gaze_x'], eyeData['gaze_y'])
plt.show()

from sklearn.cluster  import KMeans
from sklearn.preprocessing import MinMaxScaler

km = KMeans(n_clusters = 4)
y_predicted   = km.fit_predict(eyeData[features])

eyeData['cluster']  = y_predicted
eyeData.head()

df1 = eyeData[eyeData.cluster == 1]


df4 = eyeData[eyeData.cluster ==0]
df1 = df1.head(10)


df4 = df4.head(10)

import matplotlib.pyplot as plt
a = 'gaze_x'
b = 'headPose_x'
plt.scatter(df1[a] , df1[b] ,color='red')


plt.scatter(df4[a] , df4[b], color='black')

plt.legend()

#normalizing the values
scalar = MinMaxScaler()

x = eyeData['iris_x'].values.reshape(-1,1)
eyeData['iris_x'] = scalar.fit_transform(x)

x = eyeData['iris_y'].values.reshape(-1,1)
eyeData['iris_y'] = scalar.fit_transform(x)

x = eyeData['headPose_x'].values.reshape(-1,1)
eyeData['headPose_x'] = scalar.fit_transform(x)

x = eyeData['headPose_y'].values.reshape(-1,1)
eyeData['headPose_y'] = scalar.fit_transform(x)

x = eyeData['eyeCorner_x'].values.reshape(-1,1)
eyeData['eyeCorner_x'] = scalar.fit_transform(x)

x = eyeData['eyeCorner_y'].values.reshape(-1,1)
eyeData['eyeCorner_y'] = scalar.fit_transform(x)

x = eyeData['gaze_x'].values.reshape(-1,1)
eyeData['gaze_x'] = scalar.fit_transform(x)

x = eyeData['gaze_y'].values.reshape(-1,1)
eyeData['gaze_y'] = scalar.fit_transform(x)

x = eyeData['gaze_z'].values.reshape(-1,1)
eyeData['gaze_z'] = scalar.fit_transform(x)

x = eyeData['pupil_size'].values.reshape(-1,1)
eyeData['pupil_size'] = scalar.fit_transform(x)

eyeData

#eyeData.to_csv('eyeData.csv', header= True, index=False)

eyeData.corr(method ='pearson')

km.cluster_centers_

a= []
for k in  range(1,25):
  km = KMeans(n_clusters = k)
  y_predicted   = km.fit_predict(eyeData[features])
  a.append(km.inertia_)

a

plt.plot(range(1,25) , a)
plt.title('elbow method ')
plt.xlabel('k values')
plt.ylabel('Fit on predicted data')
 # elbow method

km = KMeans(n_clusters = 4)
y_predicted   = km.fit_predict(eyeData[features])

eyeData['cluster']  = y_predicted
eyeData

import numpy
y = eyeData['cluster']
numpy.min(eyeData['pupil_size'])
cls =['0','1','2','3']

x = eyeData[features]
x

from sklearn.model_selection import train_test_split
x_train,x_test,y_train,y_test = train_test_split(x,y,test_size=0.2,random_state=60)

from sklearn import tree
tree_model =tree.DecisionTreeClassifier()
tree_model.fit(x_train,y_train)

text_representation = tree.export_text(tree_model)
print(text_representation)

from sklearn import metrics
y_pred = tree_model.predict(x_test)
print("Accuracy:",metrics.accuracy_score(y_test, y_pred))

from sklearn import svm
clf = svm.SVC()
clf.fit(x_train, y_train)

y_pred = clf.predict(x_test)

from sklearn.metrics import classification_report
print("Accuracy:",metrics.accuracy_score(y_test, y_pred))
print(classification_report(y_test, y_pred, target_names=cls))



from sklearn.linear_model import SGDClassifier

clf = SGDClassifier(loss="hinge", penalty="l2", max_iter=100)
clf.fit(x_train,y_train)

y_pred = clf.predict(x_test)

print("Accuracy:",metrics.accuracy_score(y_test, y_pred))

y_pred

from sklearn.cluster import DBSCAN

clustering = DBSCAN(eps=12.5, min_samples=4000).fit(x_train)
DBSCAN_dataset = x_train.copy()
DBSCAN_dataset.loc[:,'Cluster'] = clustering.labels_

DBSCAN_dataset.Cluster.value_counts().to_frame()

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.cluster import DBSCAN

outliers = DBSCAN_dataset[DBSCAN_dataset['Cluster']==-1]

fig2, (axes) = plt.subplots(1,2,figsize=(12,5))

sns.scatterplot(features[0],  features[1],

                data=DBSCAN_dataset[DBSCAN_dataset['Cluster']!=-1],

                hue='Cluster', ax=axes[0], palette='Set2', legend='full', s=200)

sns.scatterplot(features[1],features[2],

                data=DBSCAN_dataset[DBSCAN_dataset['Cluster']!=-1],

                hue='Cluster', palette='Set2', ax=axes[1], legend='full', s=200)

axes[0].scatter(outliers[features[0] ], outliers[features[1]], s=10, label='outliers', c="k")

axes[1].scatter(outliers[features[2]], outliers[features[3]], s=10, label='outliers', c="k")
axes[0].legend()
axes[1].legend()

plt.setp(axes[0].get_legend().get_texts(), fontsize='12')
plt.setp(axes[1].get_legend().get_texts(), fontsize='12')

plt.show()

from sklearn.mixture import GaussianMixture
gmm = GaussianMixture(n_components=4)
gmm.fit(x)

#predictions from gmm
labels = gmm.predict(x)
frame = pd.DataFrame(x)
frame['cluster'] = labels
frame.columns = features1

color=['blue','green','cyan', 'black','yellow']
for k in range(0,4):
    data = frame[frame["cluster"]==k]
    plt.scatter(data['headPose_x'],data["gaze_x"],c=color[k])
plt.show()

y = frame['cluster']

from sklearn.naive_bayes import GaussianNB
model = GaussianNB()
model.fit(x_train,y_train);

y_pred = model.predict(x_test)

print("Accuracy:",metrics.accuracy_score(y_test, y_pred))

from sklearn.neighbors import KNeighborsClassifier

model = KNeighborsClassifier(n_neighbors=100)

# Train the model using the training sets
model.fit(x_train, y_train)

y_pred = model.predict(x_test)

